import uuid
import shlex
import logging
from spotad import context
import subprocess
import os
import shutil
from pathlib2 import Path
from operator import methodcaller
import re
import numpy as np
from collections import namedtuple

_TRAIN_COMMAND_TEMPLATE = "{ranger_bin} --file {train_file} --treetype 1 --probability" + \
                          " --memmode 1 --seed {random_seed} --caseweights {train_file}.case_weights" + \
                          " --depvarname __label__ --write --outprefix {out-name} --splitrule 1" + \
                          " --ntree {ntree} --fraction {fraction} --targetpartitionsize {min-node-size}"

_PREDICT_COMMAND_TEMPLATE = "{ranger_bin} --file {prediction_file} --seed {random_seed}" + \
                            " --predict {out-name}.forest --outprefix {out-name}"

_FNULL = open(os.devnull, 'w')  # /dev/null stream

WHITESPACE = re.compile(r'\s+')

PredictionAndProbability = namedtuple("PredictionAndProbability", ['predictions', 'probabilities'])


def _load_prediction(file_name):
    """
    Load the predictions and probabilities of those predictions from the ranger (non standard) format 
    
    :param str file_name: path to ranger generated prediction file
    :return: prediction information with predictions and probabilities
    :rtype: PredictionAndProbability
    """
    with open(file_name, 'r') as f:
        next(f)  # ignore the explanation line
        header_line = next(f).strip()
        # figure out what index represents the positive labels
        true_label_index = WHITESPACE.split(header_line).index("1")

        next(f)  # ignore empty line

        pred_and_prob = list(map(lambda p: (p, 1 if p > 0.5 else 0),
                            [float(WHITESPACE.split(line)[true_label_index])
                             for line in map(methodcaller('strip'), f)]))

        prediction_probability, prediction = zip(*pred_and_prob)

        prediction_probability = np.asarray(prediction_probability, dtype=np.float64).reshape(
            (len(prediction_probability), 1))
        prediction = np.asarray(prediction, dtype=np.uint8).reshape((len(prediction), 1))

        return PredictionAndProbability(prediction, prediction_probability)


class RangerModel(object):
    """
    A representation of a ranger model. It's implemented as a context manger to help with cleaning up the temporary 
    model files that will be generated by the ranger binary. The actual training process executes at the beginning 
    of a 'with' block and the temporary files are deleted after the block terminates.
    """

    def __init__(self, ranger_bin, data_set_file, ntree, fraction, min_target_node_size, tmp_folder, random_seed=1):
        """
        
        :param str ranger_bin: The location of the ranger binary
        :param str data_set_file: The location of the data set on which we want to train this model
        :param int ntree: Number of trees to construct during training
        :param int min_target_node_size: Minimal node size
        :param float fraction: The fraction of examples each tree will be exposed to
        :param pathlib2.Path tmp_folder: A temporary folder where ranger intermediate files can be stored
        :param int random_seed: a random seed (must be >= 1)
        """
        self._ranger_bin = ranger_bin
        self._data_set_file = data_set_file
        self._ntree = ntree
        self._fraction = fraction
        self._min_target_node_size = min_target_node_size
        self._tmp_folder = tmp_folder
        self._random_seed = random_seed
        self._logger = logging.getLogger('RangerModel')

        self._context_available = False
        self._model_name = None

    def _validate_context(self):
        """
        Utility that raises an exception if called while accessed from outside of a 'with' block 
        """
        if not self._context_available:
            raise Exception('can only be used inside a with statement')

    def _get_ranger_bin(self):
        """
        Get a ranger binary path, if no manual path was specified, return the default
        :return: the path
        :rtype: str
        """
        if self._ranger_bin is None:
            return os.path.join(os.path.dirname(__file__), '_c/ranger')
        else:
            return self._ranger_bin


    def __enter__(self):
        """
        Train the model, and generate the ranger model file
        :return: 
        :rtype: RangerModel
        """

        # execute train and generate model file
        self._model_name = uuid.uuid4()

        # make sure the ranger bin has an executable permission
        os.chmod(self._get_ranger_bin(), 0o777)

        ranger_train_params = {
            'ranger_bin': self._get_ranger_bin(),
            'train_file': self._data_set_file,
            'random_seed': self._random_seed,
            'fraction': self._fraction,
            'ntree': self._ntree,
            'min-node-size' : self._min_target_node_size,
            'out-name': self._model_name
        }

        ranger_command = shlex.split(_TRAIN_COMMAND_TEMPLATE.format(**ranger_train_params))
        self._logger.debug('executing: %s', ' '.join(ranger_command))

        with context.log("Training a ranger model for num_trees:%d, fraction:%f from: %s",
                         self._ntree, self._fraction, self._data_set_file, logger=self._logger):
            ranger_process = subprocess.Popen(
                ranger_command,
                stdout=_FNULL,  # forward process stdout to /dev/null
                cwd=self._tmp_folder.as_posix())  # working directory
            status = ranger_process.wait()
            if status != 0:
                self._logger.error("Training failed for num_trees:%d, fraction:%f", self._ntree, self._fraction)
                return None

        model_file = self._tmp_folder / '{}.forest'.format(self._model_name)
        self._logger.info('Created a temporary model file: %s', model_file.as_posix())
        self._context_available = True
        return self

    def __exit__(self, exception_type, exception_value, traceback):
        """
        Cleanup the temporary model file created by __enter__(training)
        
        :param exception_type: 
        :param exception_value: 
        :param traceback: 
        """
        # delete model file
        model_file = self._tmp_folder / '{}.forest'.format(self._model_name)
        self._logger.info('Deleting a temporary model file: %s', model_file.as_posix())
        os.remove(model_file.as_posix())

        self._context_available = False

    def predict(self, data_set):
        """
        Run a prediction of the model of some data set.
        Will raise an error if used outside a 'with' block
        
        :param str data_set: a path to a data set
        :return: predictions and the corresponding probabilities of running the model on the data set
        :rtype: PredictionAndProbability
        """
        self._validate_context()

        ranger_predict_params = {
            'ranger_bin': self._get_ranger_bin(),
            'random_seed': self._random_seed,
            'prediction_file': data_set,
            'out-name': self._model_name
        }

        ranger_command = shlex.split(_PREDICT_COMMAND_TEMPLATE.format(**ranger_predict_params))
        self._logger.debug('executing: %s', ' '.join(ranger_command))

        ranger_process = subprocess.Popen(
            ranger_command,
            stdout=_FNULL,  # forward process stdout to /dev/null
            cwd=self._tmp_folder.as_posix())  # working directory
        status = ranger_process.wait()
        if status != 0:
            raise Exception('Prediction process failed')

        prediction_file = (self._tmp_folder / "{}.prediction".format(self._model_name)).as_posix()
        predictions_and_probabilities = _load_prediction(prediction_file)

        # delete the prediction file that is no longer needed
        os.remove(prediction_file)

        return predictions_and_probabilities

    def save(self, file_name):
        """
        Create a copy of the temporary model file in some other location for later use
        Will raise an error if used outside of a 'with' block
        
        :param str file_name: path where to save the model
        """
        self._validate_context()
        self._logger.info('Saving model to: %s', file_name)
        with context.log("copy model from temporary folder to: %s", file_name, logger=self._logger):
            shutil.copy((self._tmp_folder / '{}.forest'.format(self._model_name)).as_posix(), file_name)


class RangerTrainer(object):
    """
    This a ranger model factory, where fit creates a new model. It's intended to be used in combination
    with the 'with' statement, as the RangerModel is a context manger.
    """

    def __init__(self, ranger_bin, tmp_folder=Path('/tmp'), random_seed=1):
        """
        :param str ranger_bin: The location of the ranger binary
        :param pathlib2.Path tmp_folder: a location of a temporary folder where its possible to store intermediate files
        :param int random_seed: random seed
        """
        self._ranger_bin = ranger_bin
        self._tmp_folder = tmp_folder
        self._random_seed = random_seed

    def fit(self, data_set, ntree=500, fraction=1.0, min_target_node_size=1):
        """
        Create a RangerModel from a specified data set
        
        :param str data_set: path to a data set file (label column should be named __label__)
        :param int ntree: number of trees to construct during training
        :param float fraction: the fraction of examples that will be presented to every tree during training
        :param int min_target_node_size: Minimal node size
        :return: an object representing the ranger model
        :rtype: RangerModel
        """
        return RangerModel(self._ranger_bin, data_set, ntree, fraction, min_target_node_size,
                           random_seed=self._random_seed,
                           tmp_folder=self._tmp_folder)
